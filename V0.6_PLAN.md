# V0.6 Implementation Plan: Groups Foundation

## Overview

Add the ability to create groups and manage members. This is the foundation for V0.9's group calendar feature.

---

## Issues Addressed in This Plan

| Issue | Risk | Solution |
|-------|------|----------|
| RLS self-reference complexity | Hard to audit, potential inefficiency | Use `IN (UNION)` pattern â€” single subquery, clear access paths |
| Missing `remove_group_member` RPC | Inconsistent with CLAUDE.md rules | Added RPC with error codes |
| Missing `create_group` RPC | Name validation not in single source of truth | Added RPC with validation + error codes |
| Direct member insert/delete | Bypasses validation | RLS policies block direct access; only RPC allowed |
| Trigger vs RPC for auto-add creator | Complexity | Removed trigger; creator added atomically in `create_group` RPC |
| `CANNOT_ADD_SELF` redundant | Confusing error codes | Removed; `ALREADY_MEMBER` covers this case |
| Owner can't see members if not in group_members | Owner locked out of management | Owner path is first-class in UNION (groups WHERE created_by) |
| Race condition on 20-member limit | Could exceed limit with concurrent requests | Added trigger constraint to enforce at DB level |

---

## Core Invariants

| # | Invariant | Enforced By |
|---|-----------|-------------|
| I1 | User can only see groups they belong to | RLS on `groups` |
| I2 | User can only see members of groups they belong to | RLS on `group_members` (includes owner check) |
| I3 | User can only create groups for themselves | RLS + RPC |
| I4 | Only creator can add members | RPC + RLS blocks direct insert |
| I5 | Only creator can remove members | RPC + RLS blocks direct delete |
| I6 | Only creator can delete group | RLS on `groups` |
| I7 | User cannot be added twice | DB UNIQUE constraint |
| I8 | Max 20 members per group | DB trigger + RPC check |
| I9 | Group name 3-30 characters | DB CHECK constraint + RPC |
| I10 | Creator cannot remove themselves | RPC |
| I11 | Creator is always a member | RPC atomic insert (plpgsql transaction) |

---

## Pre-Implementation Checklist (per CLAUDE.md)

### 1. Where is the single source of truth?
- **Groups**: `groups` table
- **Membership**: `group_members` table
- **Add member**: `add_group_member` RPC function (atomic, with error codes)

### 2. What are the exact result codes?

**Create Group:**
- `SUCCESS` - Group created
- `INVALID_NAME` - Name too short/long (3-30 chars)
- `UNAUTHORIZED` - Not logged in
- `UNKNOWN_ERROR` - Unexpected failure

**Add Member:** (8 codes, each appears exactly once)
- `SUCCESS` - Member added
- `GROUP_NOT_FOUND` - Group doesn't exist
- `NOT_OWNER` - Only creator can add members
- `USER_NOT_FOUND` - Username doesn't exist
- `ALREADY_MEMBER` - User is already in group (any user, including owner trying to re-add self)
- `GROUP_FULL` - Max 20 members reached
- `UNAUTHORIZED` - Not logged in
- `UNKNOWN_ERROR` - Unexpected failure

> Note: `CANNOT_ADD_SELF` was removed. When owner tries to add themselves, `ALREADY_MEMBER` is returned because they were auto-added on group creation. This is accurate and simpler than special-casing.

**Remove Member:**
- `SUCCESS` - Member removed
- `GROUP_NOT_FOUND` - Group doesn't exist
- `NOT_OWNER` - Only creator can remove members
- `CANNOT_REMOVE_SELF` - Creator cannot leave (must delete group)
- `MEMBER_NOT_FOUND` - User not in group
- `UNAUTHORIZED` - Not logged in
- `UNKNOWN_ERROR` - Unexpected failure

### 3. Can this operation partially succeed?
- **Create group**: No - single insert
- **Add member**: No - single insert via RPC
- **Remove member**: No - single delete

### 4. What happens if two users act simultaneously?
- **Add same member twice**: DB unique constraint prevents duplicates, RPC returns `ALREADY_MEMBER`
- **Remove while adding**: One succeeds, other gets appropriate error

### 5. How does the UI know the operation succeeded?
- All mutations return result codes
- UI refetches from DB after success (no state guessing)

### 6. What logic will be deleted to prevent duplication?
- N/A - new feature, no existing code

---

## Implementation Order

### Phase 1: Database (006_add_groups.sql)

```sql
-- Migration: Add groups feature
-- Date: 2026-01-13
-- Description: Tables and functions for group management

-- ============================================================================
-- TABLES
-- ============================================================================

CREATE TABLE groups (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  created_by UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

  CONSTRAINT group_name_length CHECK (char_length(trim(name)) BETWEEN 3 AND 30)
);

CREATE TABLE group_members (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  group_id UUID NOT NULL REFERENCES groups(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

  UNIQUE(group_id, user_id)
);

-- ============================================================================
-- INDEXES
-- ============================================================================

CREATE INDEX idx_groups_created_by ON groups(created_by);
CREATE INDEX idx_group_members_group ON group_members(group_id);
CREATE INDEX idx_group_members_user ON group_members(user_id);

-- ============================================================================
-- ROW LEVEL SECURITY
-- ============================================================================

ALTER TABLE groups ENABLE ROW LEVEL SECURITY;
ALTER TABLE group_members ENABLE ROW LEVEL SECURITY;

-- Groups: Users can view groups they created or are members of
CREATE POLICY "Users can view own groups"
  ON groups FOR SELECT
  USING (
    created_by = auth.uid()
    OR id IN (SELECT group_id FROM group_members WHERE user_id = auth.uid())
  );

-- Groups: Users can create groups (created_by must be self)
CREATE POLICY "Users can create groups"
  ON groups FOR INSERT
  WITH CHECK (created_by = auth.uid());

-- Groups: Only creators can delete their groups
CREATE POLICY "Creators can delete groups"
  ON groups FOR DELETE
  USING (created_by = auth.uid());

-- Group Members: Users can view members of groups they have access to
-- Note: Derives visibility through groups table, minimal self-reference
CREATE POLICY "Members can view group members"
  ON group_members FOR SELECT
  USING (
    group_id IN (
      -- All groups this user has access to (owner OR member)
      SELECT id FROM groups WHERE created_by = auth.uid()
      UNION
      SELECT group_id FROM group_members WHERE user_id = auth.uid()
    )
  );

-- Group Members: Insert/Delete handled by RPC functions (SECURITY DEFINER)
-- Direct insert/delete blocked for safety
CREATE POLICY "Block direct member inserts"
  ON group_members FOR INSERT
  WITH CHECK (false);

CREATE POLICY "Block direct member deletes"
  ON group_members FOR DELETE
  USING (false);

-- ============================================================================
-- TRIGGER: Enforce 20-member limit at DB level (prevents race conditions)
-- ============================================================================

CREATE OR REPLACE FUNCTION enforce_group_member_limit()
RETURNS TRIGGER AS $$
BEGIN
  IF (SELECT COUNT(*) FROM group_members WHERE group_id = NEW.group_id) >= 20 THEN
    RAISE EXCEPTION 'GROUP_FULL: Maximum 20 members per group';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_group_member_limit
  BEFORE INSERT ON group_members
  FOR EACH ROW
  EXECUTE FUNCTION enforce_group_member_limit();

-- ============================================================================
-- RPC: create_group
-- ============================================================================
-- Single source of truth for group creation with error codes

CREATE OR REPLACE FUNCTION create_group(group_name TEXT)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_current_user_id UUID;
  v_trimmed_name TEXT;
  v_group_id UUID;
BEGIN
  v_current_user_id := auth.uid();

  IF v_current_user_id IS NULL THEN
    RETURN '{"code": "UNAUTHORIZED"}'::JSON;
  END IF;

  v_trimmed_name := trim(group_name);

  -- Validate name length
  IF char_length(v_trimmed_name) < 3 OR char_length(v_trimmed_name) > 30 THEN
    RETURN '{"code": "INVALID_NAME"}'::JSON;
  END IF;

  -- Create group
  INSERT INTO groups (name, created_by)
  VALUES (v_trimmed_name, v_current_user_id)
  RETURNING id INTO v_group_id;

  -- Auto-add creator as first member
  INSERT INTO group_members (group_id, user_id)
  VALUES (v_group_id, v_current_user_id);

  RETURN json_build_object('code', 'SUCCESS', 'group_id', v_group_id);

EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object('code', 'UNKNOWN_ERROR', 'detail', SQLERRM);
END;
$$;

-- ============================================================================
-- RPC: add_group_member
-- ============================================================================
-- Single source of truth for adding members with error codes

CREATE OR REPLACE FUNCTION add_group_member(p_group_id UUID, member_username TEXT)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_member_id UUID;
  v_current_user_id UUID;
  v_group_owner_id UUID;
  v_member_count INTEGER;
BEGIN
  v_current_user_id := auth.uid();

  IF v_current_user_id IS NULL THEN
    RETURN '{"code": "UNAUTHORIZED"}'::JSON;
  END IF;

  -- Get group owner
  SELECT created_by INTO v_group_owner_id FROM groups WHERE id = p_group_id;

  IF v_group_owner_id IS NULL THEN
    RETURN '{"code": "GROUP_NOT_FOUND"}'::JSON;
  END IF;

  IF v_group_owner_id != v_current_user_id THEN
    RETURN '{"code": "NOT_OWNER"}'::JSON;
  END IF;

  -- Find member by username (case-insensitive)
  SELECT id INTO v_member_id
  FROM profiles
  WHERE lower(username) = lower(trim(member_username));

  IF v_member_id IS NULL THEN
    RETURN '{"code": "USER_NOT_FOUND"}'::JSON;
  END IF;

  -- Check if already member
  IF EXISTS (SELECT 1 FROM group_members WHERE group_id = p_group_id AND user_id = v_member_id) THEN
    RETURN '{"code": "ALREADY_MEMBER"}'::JSON;
  END IF;

  -- Check member count (max 20)
  SELECT COUNT(*) INTO v_member_count FROM group_members WHERE group_id = p_group_id;
  IF v_member_count >= 20 THEN
    RETURN '{"code": "GROUP_FULL"}'::JSON;
  END IF;

  -- Insert member
  INSERT INTO group_members (group_id, user_id) VALUES (p_group_id, v_member_id);

  RETURN json_build_object('code', 'SUCCESS', 'member_id', v_member_id);

EXCEPTION
  WHEN unique_violation THEN
    RETURN '{"code": "ALREADY_MEMBER"}'::JSON;
  WHEN raise_exception THEN
    -- Catch trigger exception for GROUP_FULL (race condition fallback)
    IF SQLERRM LIKE 'GROUP_FULL%' THEN
      RETURN '{"code": "GROUP_FULL"}'::JSON;
    END IF;
    RETURN json_build_object('code', 'UNKNOWN_ERROR', 'detail', SQLERRM);
  WHEN OTHERS THEN
    RETURN json_build_object('code', 'UNKNOWN_ERROR', 'detail', SQLERRM);
END;
$$;

-- ============================================================================
-- RPC: remove_group_member
-- ============================================================================
-- Single source of truth for removing members with error codes

CREATE OR REPLACE FUNCTION remove_group_member(p_group_id UUID, p_member_id UUID)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_current_user_id UUID;
  v_group_owner_id UUID;
  v_deleted_count INTEGER;
BEGIN
  v_current_user_id := auth.uid();

  IF v_current_user_id IS NULL THEN
    RETURN '{"code": "UNAUTHORIZED"}'::JSON;
  END IF;

  -- Get group owner
  SELECT created_by INTO v_group_owner_id FROM groups WHERE id = p_group_id;

  IF v_group_owner_id IS NULL THEN
    RETURN '{"code": "GROUP_NOT_FOUND"}'::JSON;
  END IF;

  IF v_group_owner_id != v_current_user_id THEN
    RETURN '{"code": "NOT_OWNER"}'::JSON;
  END IF;

  -- Cannot remove self (owner)
  IF p_member_id = v_current_user_id THEN
    RETURN '{"code": "CANNOT_REMOVE_SELF"}'::JSON;
  END IF;

  -- Delete member
  DELETE FROM group_members
  WHERE group_id = p_group_id AND user_id = p_member_id;

  GET DIAGNOSTICS v_deleted_count = ROW_COUNT;

  IF v_deleted_count = 0 THEN
    RETURN '{"code": "MEMBER_NOT_FOUND"}'::JSON;
  END IF;

  RETURN '{"code": "SUCCESS"}'::JSON;

EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object('code', 'UNKNOWN_ERROR', 'detail', SQLERRM);
END;
$$;

-- ============================================================================
-- GRANTS
-- ============================================================================

GRANT EXECUTE ON FUNCTION create_group(TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION add_group_member(UUID, TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION remove_group_member(UUID, UUID) TO authenticated;
```

### Phase 2: Types (src/types/group.ts)

```typescript
export interface Group {
  id: string;
  name: string;
  created_by: string;
  created_at: string;
  member_count?: number; // Derived
  is_owner?: boolean;    // Derived
}

export interface GroupMember {
  id: string;
  group_id: string;
  user_id: string;
  joined_at: string;
  // Joined from profiles:
  username: string;
  display_name: string | null;
  avatar_type: string;
  avatar_color: string;
}

export type CreateGroupCode =
  | 'SUCCESS'
  | 'INVALID_NAME'
  | 'UNAUTHORIZED'
  | 'UNKNOWN_ERROR';

// Ordered by check sequence in RPC
export type AddMemberCode =
  | 'SUCCESS'
  | 'UNAUTHORIZED'      // First check: auth.uid()
  | 'GROUP_NOT_FOUND'   // Group lookup
  | 'NOT_OWNER'         // Ownership check
  | 'USER_NOT_FOUND'    // Username lookup
  | 'ALREADY_MEMBER'    // Membership check (includes self-add attempt)
  | 'GROUP_FULL'        // Count check + trigger fallback
  | 'UNKNOWN_ERROR';    // Exception handler

// Deterministic frontend mapping (1:1)
const ADD_MEMBER_MESSAGES: Record<AddMemberCode, string> = {
  SUCCESS: 'Member added!',
  UNAUTHORIZED: 'You must be logged in.',
  GROUP_NOT_FOUND: 'Group not found.',
  NOT_OWNER: 'Only the group creator can add members.',
  USER_NOT_FOUND: 'User not found. Check the username.',
  ALREADY_MEMBER: 'This user is already in the group.',
  GROUP_FULL: 'Group is full (max 20 members).',
  UNKNOWN_ERROR: 'Something went wrong. Please try again.',
};

export type RemoveMemberCode =
  | 'SUCCESS'
  | 'GROUP_NOT_FOUND'
  | 'NOT_OWNER'
  | 'CANNOT_REMOVE_SELF'
  | 'MEMBER_NOT_FOUND'
  | 'UNAUTHORIZED'
  | 'UNKNOWN_ERROR';

export interface CreateGroupResult {
  success: boolean;
  code: CreateGroupCode;
  group?: Group;
  error?: string;
}

export interface AddMemberResult {
  success: boolean;
  code: AddMemberCode;
  error?: string;
}

export interface RemoveMemberResult {
  success: boolean;
  code: RemoveMemberCode;
  error?: string;
}
```

### Phase 3: Hooks

**useGroups.ts** - List groups, create group, delete group
**useGroupMembers.ts** - List members, add member, remove member

### Phase 4: Components

1. `GroupsPage.tsx` - List user's groups + create form
2. `GroupDetailPage.tsx` - View/manage single group
3. `CreateGroupForm.tsx` - Name input + submit
4. `GroupCard.tsx` - Display group in list
5. `GroupMembersList.tsx` - List members with avatars
6. `AddMemberForm.tsx` - Username input + submit

### Phase 5: Navigation

- Add "Groups" link to HomePage header
- Add route `/groups` and `/groups/:id`

---

## File Creation Order

1. `supabase/migrations/006_add_groups.sql`
2. `src/types/group.ts`
3. `src/hooks/useGroups.ts`
4. `src/hooks/useGroupMembers.ts`
5. `src/components/CreateGroupForm.tsx`
6. `src/components/GroupCard.tsx`
7. `src/components/GroupMembersList.tsx`
8. `src/components/AddMemberForm.tsx`
9. `src/pages/GroupsPage.tsx`
10. `src/pages/GroupDetailPage.tsx`
11. Update `src/App.tsx` - Add routes
12. Update `src/pages/HomePage.tsx` - Add nav link

---

## Testing Checklist

- [ ] Create group with valid name (3-30 chars)
- [ ] Create group with invalid name (< 3 or > 30 chars) - should fail
- [ ] Creator is auto-added as member
- [ ] Add member by username
- [ ] Add member with invalid username - should fail
- [ ] Add duplicate member - should fail with ALREADY_MEMBER
- [ ] Non-owner tries to add member - should fail with NOT_OWNER
- [ ] Add 20th member - should succeed
- [ ] Add 21st member - should fail with GROUP_FULL
- [ ] Remove member (as owner)
- [ ] Non-owner tries to remove - should fail
- [ ] Delete group (as owner)
- [ ] RLS: User can only see groups they belong to
